<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      a {
        color: #F92672;
        text-decoration: none;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }

      .inverse {
        background: #272822;
        color: #777872;
        text-shadow: 0 0 20px #333;
      }
      .inverse h1, .inverse h2 {
        color: #f3f3f3;
        line-height: 0.8em;
      }

    </style>
  </head>
  <body>
    <textarea id="source">

class: center, middle, inverse

# Build systems

## Some thoughts...

Johan Herland < <jherland@cisco.com> >

???

Who am I?

- Platform developer in TC/CE software group
- Currently on the Sunrise project
- Resident Git Guru

---

# Agenda

1. Building software
2. Properties of _bad_ build systems
3. Properties of _good_ build systems
4. The core of a good build system
5. Techniques for improving build systems
6. Conclusions
7. Q&A

---
layout: false
class: center, middle, inverse

# Building software

---
template: default
layout: true

### Building software
---

- What is a build process?
- What is a build system?
- Various kinds of "building" and "software"
- Extracting some common concepts
- Reframing the problem

---

Source file &rarr; Executable

---

Source files &rarr; Object files &rarr; Executable
    - Source files -> Object files -> Library + Executable
    - + tests?
    - + stripped vs. debug executables?
    - multiple targets?
    - autogenerated source files?
    - multiple executables?
    - linking against external libs?
        - external prebuilt? or built at the same time?
    - subprojects, external dependencies, triggering other build systems?
    - collecting executables and libs into a distro package (.deb, .rpm, .tar.gz)?
    - assembling filesystem images?
    - creating upgrade packages (.pkg)?

    (
    - also applies to "building" other kinds of "software":
        - Building FPGA image and corresponding header files from VHDL code and FPGA config/specification
        - Building a web site of static HTML files from source text files
        - Building a PDF document from LaTeX source
    )

---

Common themes:
    - Build process comprises one or more build steps
    - Trivial build process: Shell script that does eveything in a serial manner -> entire build process is one step
    - Better organize steps in a directed acyclic graph 
    - Each step has a set of inputs, a set of outputs, and some process that is performed to generate the outputs from the inputs
    - Steps may be nested
        - A step can be divided into substeps
        - A group of steps (to e.g. produce a library) can be considered as a single build step
    - Incremental build:
        - Figure out which steps that DON'T need to be rebuilt
        - Drill down! Only rebuild the smallest thing needed
            - Rebuild a single source files, and then re-link executable, instead of rebuilding all of the executable.
    - Each step:
        - What are the inputs?
        - Really? Are there more inputs?
            - Toolchains
            - Command-line options
            - Environment!
            - Locale(!?)
        - Dependency is really just another name for INPUT!
        - What are the outputs?

        - Examples:
            - Compiling hello.c -> hello:
                - Obvious:
                    - INPUT: Source file
                    - OUTPUT: Executable:
                - Not so obvious:
                    - Compiler options:
                        - -g, -O3 -L/path/to/my/library? -> INPUT
                    - Compiler version?
                        - GCC vs. Clang, C++11 support?
                    - Environment:
                        - $PATH
                        - $TMPDIR, $COMPILER_PATH, $LIBRARY_PATH
                        - $LANG (locale!?)
            - Autogenerated source files:
                - INPUT: Some input source passed to the generator
                - OUTPUT: The generated source
                - INPUT: The generator itself
                - INPUT: The command line and environment passed to the generator
                - That's the first step, what happens next?
                - INPUT: generated source
                - OUTPUT: compiled source
                - INPUT: Compiler, its command line and environment

            - Building a subproject, e.g. libfoo:
                - INPUT: A libfoo source tree, maybe unpacked from some tarball, or checked out from some git repo?
                - INPUT: The command lines and environment needed to build (and install?) the subproject
                - OUTPUT: The build products (executables, libraries, config files, etc.)
                - Don't forget: INPUT: The tools needed to build the subproject: compiler?, interpreter?, its build system (make, cmake, etc.)?

            - Assembling a file system image:
                - INPUT: The stuff that is put into the FS
                - INPUT: The FS generator tool, its command line and environment
                - OUTPUT: The FS image

---
layout: false
class: center, middle, inverse

# Properties of _bad_ build systems

---
template: default
layout: true

### Properties of _bad_ build systems
---

    - Works on _that_ machine, but not on my machine
        - Different:
            - compilers?
            - compiler versions?
            - tools? versions?
            - hosts
            - users
            - distros
            - environments
            - locales
            - networks

    - Always build release builds from clean
        - Cannot trust incremental builds
        - Fast or correct, choose one!

    - Slow
        - Unnecessary rebuilds
        - Lack of parallellization

    - Depends on externals
        - What are externals?
            - Other directories
            - Other machines
                - NFS mounts?
                - Git servers?
            - Other networks/companies

---
layout: false
class: center, middle, inverse

# Properties of _good_ build systems

---
template: default
layout: true

### Properties of _good_ build systems
---

    - Correct!
        - Incremental builds are correct
        - Builds correctly everywhere (different hosts/distros/OSes)

    - Fast!
        - No unnecessary rebuilds
        - No waiting around
        - Parallel (when possible)

---
layout: false
class: center, middle, inverse

# The core of a good build system

---
template: default
layout: true

### The core of a good build system
---


    - Aside: Functional programming:
        - Composing functions
        - Pure functions
            - has no side effects
            - can be memoized
            - can be safely parallellized

    - No side-effects!
        - Enables safe parallellization
        - Out-of-tree builds
        - DO NOT rewrite your inputs. Create new files instead...

    - Cross-compiling, toolchains
        - Control your tools!
        - Cross-compiling is the norm!?

    - Idempotence to the extreme:
        - Same input yields same output. ALWAYS!
        - Did you catch ALL the inputs?
        - Dealing with randomess
            - Two kinds of randomness:
                - Arbitrary changes: ELIMINATE THEM!
                - True/real/necessary reandomness: COMPARTMENTALIZE!

---
layout: false
class: center, middle, inverse

# Techniques for improving build systems

---
template: default
layout: true

### Techniques for improving build systems
---

Techniques for examining/debugging/improving build systems:

    - strace
        - on the whole thing?
        - on individual steps?

    - tweak the FS:
        - Read-only source tree
        - chroot/container to limit access to host tools

    - diff:
        - build logs
            - hard when parallellism is involved.
            - hard when 
        - build results

---
layout: false
class: center, middle, inverse

# Conclusions

---
template: default
layout: true

### Conclusions
---


    - Invest time

---
layout: false
class: center, middle, inverse

# Q&A

---
class: center, middle, inverse

# Thank you!

## Johan Herland &lt;<a href="mailto:jherland@cisco.com">jherland@cisco.com</a>&gt;

Slideshow created with [remark](http://gnab.github.com/remark).

    </textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
