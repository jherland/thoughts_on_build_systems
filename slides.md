class: center, middle, inverse

# Build systems

## Some thoughts...

Johan Herland < <jherland@cisco.com> >

???

Who am I?

- Platform developer in TC/CE software group
- Currently on the Sunrise project
- Resident Git Guru

---

# Agenda

1. Building software
2. Properties of _bad_ build systems
3. Properties of _good_ build systems
4. The core of a good build system
5. Techniques for improving build systems
6. Conclusions
7. Q&A

---
layout: false
class: center, middle, inverse

# Building software

---
template: default
layout: true

### Building software
---

## Terms
--

- Build process:

    - Generating build outputs from build inputs
    - e.g. building a `carbon.pkg` from a `system-trunk-main` source tree
--

- Build system:

    - The S/W that implements a build process
    - e.g. scripting, `Makefile`s, etc.

---

## Examples of build processes

- Source file &rarr; Executable
- Source files &rarr; Object files &rarr; Executable
- Source files &rarr; Object files &rarr; Library + Executable
--

- Running test suites?
- Creating stripped and/or debug executables?
- Multiple targets?
- Multiple executables?
--

- Autogenerated source files?
--

- Linking against external libs? (prebuilt or not?)
- Subprojects, external dependencies, triggering other build systems?
--

- Collecting executables and libs into a distro package (e.g. `.deb` or `.rpm`)
- Assembling filesystem images?
- Creating upgrade packages (`.pkg`)?

---

## Other examples of build processes

--

- VHDL code + FPGA config/specification &rarr; FPGA image + headers 
--

- Text documents &rarr; web site of static HTML files
--

- LaTeX source &rarr; PDF document

---

## Extracting common concepts

Build process consists of _build_ _steps_.

- Traditional/simple example:
    - `foo.c` &rarr; `foo.o`
    - `bar.c` &rarr; `bar.o`
    - `foo.o` + `bar.o` &rarr; `foobar` executable
    - 3 steps

- Trivial build process example:
    - Run a shell script that does magic &rarr; final output
    - 1 step

---

## Extracting common concepts (cont.)

A build step often _depends_ on other build steps.

- e.g. first compile object files, then link those into an executable
- the linking process _depends_ on the object files
- Therefore: the linking step _depends_ on the compilation steps

--

Organize steps into a directed acyclic graph:

- Nodes are build steps
- Edges are dependencies between build steps

We call this a _dependency_ graph.

---

## Dependency graph

![Dependency graph](dep_graph.jpg)

---

## Almost, but not quite a dependency graph

![Build flow graph](flow_graph.jpg)

---

## Extracting common concepts (cont.)

Each step has:

- a set of inputs (aka. _dependencies_)
- a set of outputs (aka. build _products_)
- some process that turns inputs &rarr; outputs, e.g.
    - invoking a compiler with appropriate options
    - running a script that does some magic...

---

## Extracting common concepts (cont.)

Steps may be nested:

- Some steps can be split into substeps
    - ( hello.c &rarr; hello.exe ) &rArr; ( hello.c &rarr; hello.o &rarr; hello.exe )

- A group of steps (i.e. a subgraph) can be grouped into a single build step
    - e.g. compiling and linking a library

---

## Building on the concepts

Clean build:
- Full traversal of the dependency graph
- Perform all build steps in the correct order to generate the required final
  output

--

Incremental build:
- Some of the build steps have already been performed
- Determine which steps that need to be redone
- Do only those steps

---

## Defining each step

- What are the inputs?
- What is the process/command?
- What are the outputs?

--

Is that all?

---

## Defining each step (cont.)

What is really the process/command?

- Command line
- Some script/program located somewhere
--

- Which version?
- Command line options?
--

- Environment??
--

- Locale!?

--

If any of them change, the build step must be rerun to be up-to-date.

&rArr; These are actually _dependencies_ of the build step!

&rArr; Add them to the list of inputs.

---

## Defining each step (cont.)

Example #1: Compiling `hello.c` &rarr; `hello.o`:

- Obvious:
    - INPUT: `hello.c`
    - OUTPUT: `hello.o`
    - COMMAND: `gcc -c hello.c -o hello.o`
--
- Not so obvious:
    - INPUT: Compiler command line
        - What if we add `-g` or `-O3` to the command line?
    - INPUT: The compiler itself
        - What if we upgrade GCC or use a different compiler?
    - INPUT: The environment passed to the compiler
        - `$PATH`
        - `$TMPDIR`, `$COMPILER_PATH`, `$LIBRARY_PATH`
        - `$LANG`

---

## Defining each step (cont.)

Example #2: Autogenerating source code:

- 2 build steps:
    1. Generate the source
    2. Compile the source

--

- First build step: Generate the source code
    - INPUT: Some original input source passed to the generator
    - OUTPUT: The generated source
--
    - INPUT: The generator itself
    - INPUT: The command line and environment passed to the generator

--

- Second build step:
    - INPUT: generated source
    - OUTPUT: compiled source
--
    - INPUT: Compiler, its command line and environment

---

## Defining each step (cont.)

Example #3: Building a subproject, e.g. `libfoo`:

- INPUT: A `libfoo` source tree
    - (unpacked from a tarball, or checked out from some git repo)
- OUTPUT: Build products (executables, libraries, config files, etc.)
- INPUT: Command line(s) and environment to build (and install?)
    `libfoo`
--

...but don't forget:

- INPUT: Tools needed to build `libfoo`:
    - compiler?
    - interpreter?
    - its build system (make, cmake, etc.)?

---

## Defining each step (cont.)

Example #4: Assembling a file system image:

- INPUT: The file structure that goes into the FS
- INPUT: The FS generator tool, its command line and environment
- OUTPUT: The FS image

---
layout: false
class: center, middle, inverse

# Properties of _bad_ build systems

---
template: default
layout: true

### Properties of _bad_ build systems
---

- Works on _that_ machine, but not on my machine
    - Different:
        - compilers?
        - compiler versions?
        - tools? versions?
        - hosts
        - users
        - distros
        - environments
        - locales
        - networks

- Always build release builds from clean
    - Cannot trust incremental builds
    - Fast or correct, choose one!

- Slow
    - Unnecessary rebuilds
    - Lack of parallellization

- Depends on externals
    - What are externals?
        - Other directories
        - Other machines
            - NFS mounts?
            - Git servers?
        - Other networks/companies

---
layout: false
class: center, middle, inverse

# Properties of _good_ build systems

---
template: default
layout: true

### Properties of _good_ build systems
---

- Correct!
    - Incremental builds are correct
    - Builds correctly everywhere (different hosts/distros/OSes)

- Fast!
    - No unnecessary rebuilds:
        - Only rebuild the smallest thing needed
            - Rebuild a single source file, and then re-link executable,
                instead of rebuilding all of the source files that make up
                the executable.
            - _Non_-example: system-trunk-os builds 3rd-party components by
                unpacking their source trees and running their build
                processes. But it cannot trust each component's build system
                to do incremental builds correctly (many don't), so each
                component always builds from scratch. This makes for few and
                large/coarse-grained build steps. Result: changing a single
                file in Android (one 3rd-party component) causes OS to
                trigger a full rebuild of _all_ of Android.
    - No waiting around
    - Parallel (when possible)


---
layout: false
class: center, middle, inverse

# The core of a good build system

---
template: default
layout: true

### The core of a good build system
---

- Aside: Functional programming:
    - Composing functions
    - Pure functions
        - has no side effects
        - can be memoized
        - can be safely parallellized

- No side-effects!
    - Enables safe parallellization
    - Out-of-tree builds
    - DO NOT rewrite your inputs. Create new files instead...

- Cross-compiling, toolchains
    - Control your tools!
    - Cross-compiling is the norm!?

- Idempotence to the extreme:
    - Same input yields same output. ALWAYS!
    - Did you catch ALL the inputs?
    - Dealing with randomess
        - Two kinds of randomness:
            - Arbitrary changes: ELIMINATE THEM!
            - True/real/necessary reandomness: COMPARTMENTALIZE!

---
layout: false
class: center, middle, inverse

# Techniques for improving build systems

---
template: default
layout: true

### Techniques for improving build systems
---

Techniques for examining/debugging/improving build systems:

- `strace`
    - on the whole thing?
    - on individual steps?

- tweak the FS
    - Read-only source tree
    - chroot/container to limit access to host tools

- `diff`
    - build logs
        - hard when parallellism is involved.
        - hard when 
    - build results

- `depfinder.py`

---
layout: false
class: center, middle, inverse

# Conclusions

---
template: default
layout: true

### Conclusions
---

- Invest time

---
layout: false
class: center, middle, inverse

# Q&A

---
class: center, middle, inverse

# Thank you!

## Johan Herland &lt;<a href="mailto:jherland@cisco.com">jherland@cisco.com</a>&gt;

Slideshow created with [remark](http://gnab.github.com/remark).
